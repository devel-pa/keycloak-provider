<?php

namespace Keycloak;

use Mockery as m;
use Illuminate\Support\Collection;
use Keycloak\AdminClient\AdminClient;
use Keycloak\AdminClient\ResourceServer;
use Keycloak\AdminClient\Values\PolicyValue;
use Keycloak\AdminClient\Values\ResourceValue;
use Keycloak\AdminClient\Values\Policy\PolicyUserValue;
use PHPUnit\Framework\TestCase;
use Tests\KeycloakFakeFactoryTrait;

class AdminClientTest extends TestCase
{
    use KeycloakFakeFactoryTrait;

    protected $provider;

    protected $client;

    protected $realm;

    protected $clientId;

    /**
     * @var
     */
    protected $fakeTokenResponse;
    /**
     * @var
     */
    protected $fakeEntitlementResponse;


    public function setUp()
    {
        parent::setUp(); // TODO: Change the autogenerated stub

        $this->setupKeycloak();

        $this->fakeTokenResponse = $this->factoryTokenResponse();

        $this->fakeEntitlementResponse = $this->factoryPartyToken();

        // for fake keycloak
        $this->provider = new KeycloakProvider([
            'authServerUrl' => 'http://mock.url/auth',
            'realm'         => 'mock_realm',
            'clientId'      => $this->fakeClientId,
            'clientSecret'  => 'mock_secret',
            'redirectUri'   => 'none',
        ]);


        $this->client = new AdminClient($this->provider, 'admin', 'admin');
    }

    /** @test */
    public function can_get_a_collection_or_one_item_of_realm()
    {
        $realmsResponse = $this->responseFactory($this->factoryRealmsResponse());
        $tokenResponse = $this->getFakeTokenResponse();
        $realmResponse = $this->responseFactory($this->factoryRealmResponse());

        $client = m::mock('GuzzleHttp\ClientInterface');
        $client->shouldReceive('send')->times(4)->andReturn(
            $tokenResponse,
            $realmsResponse,
            $tokenResponse,
            $realmResponse
        );

        $this->setProviderClient($client); //set mocked http client to fake responses

        $adminClient = $this->client;
        /** @var AdminClient $adminClient */
        $realms = $adminClient->realms()->find();

        $this->assertInstanceOf(Collection::class, $realms);

        $firstRealm = $realms->first();

        $realm = $adminClient->realms()->find($firstRealm['realm']);

        $this->assertInstanceOf(Collection::class, $realm);
    }

    /** @test */
    public function can_get_clients_collection_or_one_item_of_realm()
    {
        $clientsResponse = $this->responseFactory($this->factoryClientsResponse());
        $tokenResponse = $this->getFakeTokenResponse();
        $clientResponse = $this->responseFactory($this->factoryClientResponse());

        $client = m::mock('GuzzleHttp\ClientInterface');
        $client->shouldReceive('send')->times(4)->andReturn(
            $tokenResponse,
            $clientsResponse,
            $tokenResponse,
            $clientResponse
        );

        $this->setProviderClient($client); //set mocked http client to fake responses

        /** @var AdminClient $adminClient */
        $adminClient = $this->client;

        $items = $adminClient->clients($this->realm)->find();

        $this->assertInstanceOf(Collection::class, $items);

        $firstItem = $items->first();

        $item = $adminClient->clients($this->realm)->find($firstItem['id']);

        $this->assertInstanceOf(Collection::class, $item);
    }

    /** @test */
    public function can_get_resources_of_client_on_realm()
    {
        $resourcesResponse = $this->responseFactory($this->factoryClientResourcesResponse());
        $tokenResponse = $this->getFakeTokenResponse();
        $resourceResponse = $this->responseFactory($this->factoryClientResourceResponse());
        $clientsResponse = $this->responseFactory($this->factoryClientsResponse());

        $client = m::mock('GuzzleHttp\ClientInterface');
        $client->shouldReceive('send')->times(8)->andReturn(
            $tokenResponse,
            $clientsResponse,
            $tokenResponse,
            $resourcesResponse,
            $tokenResponse,
            $clientsResponse,
            $tokenResponse,
            $resourceResponse
        );

        $this->setProviderClient($client); //set mocked http client to fake responses

        /** @var AdminClient $adminClient */
        $adminClient = $this->client;

        $realm = $this->fakeRealm;
        $clientId = $this->fakeClientId;

        $items = $adminClient->resourceServer($realm, $clientId)
            ->resources()
            ->find();

        $this->assertInstanceOf(Collection::class, $items);

        $firstItem = $items->first();

        $item = $adminClient->resourceServer($realm, $clientId)
            ->resources()
            ->find($firstItem['_id']);

        $this->assertInstanceOf(Collection::class, $item);
    }

    /** @test */
    public function can_create_new_resource()
    {
        $tokenResponse = $this->getFakeTokenResponse();
        $clientsResponse = $this->responseFactory($this->factoryClientsResponse());
        $newResourceResponse = $this->responseFactory($this->factoryNewClientResourceResponse());

        $client = m::mock('GuzzleHttp\ClientInterface');
        $client->shouldReceive('send')->times(4)->andReturn(
            $tokenResponse,
            $clientsResponse,
            $tokenResponse,
            $newResourceResponse
        );

        $this->setProviderClient($client); //set mocked http client to fake responses

        /** @var AdminClient $adminClient */
        $adminClient = $this->client;

        $realm = $this->realm;
        $clientId = $this->clientId;

        $newResource = $adminClient->resourceServer($realm, $clientId)
            ->resources()
            ->create(ResourceValue::forCreate("Test resource"));

        $this->assertInstanceOf(ResourceValue::class, $newResource);
        $this->assertNotNull($newResource->getId());
    }

    /** @test */
    public function can_remove_resource()
    {
        $tokenResponse = $this->getFakeTokenResponse();
        $clientsResponse = $this->responseFactory($this->factoryClientsResponse());
        $newResourceResponse = $this->responseFactory($this->factoryNewClientResourceResponse());
        $deleteResponse = $this->responseFactory(null, 204);

        $client = m::mock('GuzzleHttp\ClientInterface');
        $client->shouldReceive('send')->times(8)->andReturn(
            $tokenResponse,
            $clientsResponse,
            $tokenResponse,
            $newResourceResponse,
            $tokenResponse,
            $clientsResponse,
            $tokenResponse,
            $deleteResponse
        );

        $this->setProviderClient($client); //set mocked http client to fake responses

        /** @var AdminClient $adminClient */
        $adminClient = $this->client;

        $realm = $this->fakeRealm;
        $clientId = $this->fakeClientId;

        $newResource = $adminClient->resourceServer($realm, $clientId)
            ->resources()
            ->create(ResourceValue::forCreate("Test resource"));

        $delete = $adminClient->resourceServer($realm, $clientId)
            ->resources()
            ->delete(ResourceValue::forDelete($newResource->getId()));

        $this->assertTrue($delete);
    }

    /** @test */
    public function can_update_resource()
    {
        $tokenResponse = $this->getFakeTokenResponse();
        $clientsResponse = $this->responseFactory($this->factoryClientsResponse());
        $newResourceResponse = $this->responseFactory($this->factoryNewClientResourceResponse());
        $deleteResponse = $this->responseFactory(null, 204);
        $updatedResponse = $this->responseFactory(null, 204);

        $client = m::mock('GuzzleHttp\ClientInterface');
        $client->shouldReceive('send')->times(8)->andReturn(
            $tokenResponse, //for create resource
            $clientsResponse, //for create resource
            $tokenResponse, //for create resource
            $newResourceResponse, //for create resource
            $tokenResponse, // for update resource
            $clientsResponse, // for update resource
            $tokenResponse, // for update resource
            $updatedResponse, // for update resource
            $tokenResponse, // for delete resource
            $clientsResponse, // for delete resource
            $tokenResponse, // for delete resource
            $deleteResponse // for delete resource
        );

        $this->setProviderClient($client); //set mocked http client to fake responses
        /** @var AdminClient $adminClient */
        $adminClient = $this->client;

        $realm = $this->realm;
        $clientId = $this->clientId;
        /** @var ResourceServer\Resource $resourceServer */
        $resourceServer = $adminClient->resourceServer($realm, $clientId)->resources();

        $forTestName = "Test resource" . time();

        $newResource = $resourceServer
            ->create(ResourceValue::forCreate($forTestName));

        $name = "UpdatedNameOfResource" . time();

        $updated = $resourceServer
            ->update(ResourceValue::forUpdate($newResource, $name));

        $this->assertTrue($updated);

        // clear
        $resourceServer
            ->delete(ResourceValue::forDelete($newResource->getId()));
    }

    /** @test */
    public function can_get_list_of_policies()
    {
        $tokenResponse = $this->getFakeTokenResponse();
        $policiesResponse = $this->responseFactory($this->factoryClientsPoliciesResponse());
        $clientsResponse = $this->responseFactory($this->factoryClientsResponse());

        $client = m::mock('GuzzleHttp\ClientInterface');
        $client->shouldReceive('send')->times(4)->andReturn(
            $tokenResponse,
            $clientsResponse,
            $tokenResponse,
            $policiesResponse
        );

        $this->setProviderClient($client); //set mocked http client to fake responses
        /** @var AdminClient $adminClient */
        $adminClient = $this->client;

        $realm = $this->fakeRealm;
        $clientId = $this->fakeClientId;
        /** @var ResourceServer\Resource $resourceServer */
        $resourceServer = $adminClient->resourceServer($realm, $clientId)->policies();

        $policies = $resourceServer->find();

        $this->assertInstanceOf(Collection::class, $policies);
    }

    /** @tests */
    public function can_get_one_policy_by_it_id()
    {
        /** @var AdminClient $adminClient */
        $adminClient = $this->client;
        $realm = $this->realm;
        $clientId = $this->clientId;

        /** @var ResourceServer\Resource $resourceServer */
        $resourceServer = $adminClient->resourceServer($realm, $clientId)->policies();

        $policies = $resourceServer->find();
        $item = $resourceServer->find($policies->first()->getId());

        $this->assertInstanceOf(PolicyValue::class, $item);
    }

    /** @tests */
    public function can_get_list_user_policies()
    {
        /** @var AdminClient $adminClient */
        $adminClient = $this->client;
        $realm = $this->realm;
        $clientId = $this->clientId;

        /** @var ResourceServer\Resource $resourceServer */
        $policyUser = $adminClient->resourceServer($realm, $clientId)->policies()->user();
        $collection = $policyUser->find();

        $this->assertInstanceOf(Collection::class, $collection);
    }

    /** @tests */
    public function can_get_user_policy_by_id()
    {
        /** @var AdminClient $adminClient */
        $adminClient = $this->client;
        $realm = $this->realm;
        $clientId = $this->clientId;

        /** @var ResourceServer\Resource $resourceServer */
        $policyUser = $adminClient->resourceServer($realm, $clientId)->policies()->user();
        $collection = $policyUser->find();
        /** @var PolicyUserValue $policy */
        $policy = $collection->first();

        $policyUserValue = $policyUser->find($policy->getId());

        $this->assertInstanceOf(PolicyUserValue::class, $policyUserValue);
    }
    /** @tests */
    public function can_delete_a_user_policy()
    {
        /** @var AdminClient $adminClient */
        $adminClient = $this->client;
        $realm = $this->realm;
        $clientId = $this->clientId;

        /** @var ResourceServer\Resource $resourceServer */
        $policyUser = $adminClient->resourceServer($realm, $clientId)->policies()->user();

        $policyName = "testPolicyCreation".time();
        $newResource = $policyUser
            ->create(PolicyUserValue::forCreate($policyName,
                null,
                PolicyValue::LOGIC_POSITIVE,
                ['0c027b9f-b3d6-4103-8ac1-a0ee08b00bb7']
            ));

        $deleted = $policyUser->delete($newResource);

        $this->assertTrue($deleted);
    }
    /** @tests */
    public function can_update_user_policy()
    {
        /** @var AdminClient $adminClient */
        $adminClient = $this->client;
        $realm = $this->realm;
        $clientId = $this->clientId;

        /** @var ResourceServer\Resource $resourceServer */
        $policyUser = $adminClient->resourceServer($realm, $clientId)->policies()->user();

        $policyName = "testPolicyCreation".time();
        $newResource = $policyUser
            ->create(PolicyUserValue::forCreate($policyName,
                null,
                PolicyValue::LOGIC_POSITIVE,
                ['0c027b9f-b3d6-4103-8ac1-a0ee08b00bb7']
            ));

        $newName = "NewName".time();
        $newDescription = "New description".time();
        $newLogic = PolicyValue::LOGIC_NEGATIVE;
        $updated = $policyUser->update(PolicyUserValue::forUpdate(
            $newResource,
            $newName, $newDescription, $newLogic
        ));

        $this->assertTrue($updated);

        //$deleted = $policyUser->delete($newResource);
    }

    /** @tests */
    public function can_create_a_user_policy_user()
    {
        /** @var AdminClient $adminClient */
        $adminClient = $this->client;
        $realm = $this->realm;
        $clientId = $this->clientId;

        /** @var ResourceServer\Resource $resourceServer */
        $policyUser = $adminClient->resourceServer($realm, $clientId)->policies()->user();

        $policyName = "testPolicyCreation".time();
        $newResource = $policyUser
            ->create(PolicyUserValue::forCreate($policyName,
                null,
                PolicyValue::LOGIC_POSITIVE,
                ['0c027b9f-b3d6-4103-8ac1-a0ee08b00bb7']
            ));

        $this->assertInstanceOf(PolicyUserValue::class, $newResource);

        $deleted = $policyUser->delete($newResource);

        $this->assertTrue($deleted);
    }
}
